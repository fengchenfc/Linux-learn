# shell

## 什么是shell

- 在Linux内核与用户之间的解释器程序
  - 通常指/bin/bash
  - 负责向内核翻译及传达用户/程序的指令	
  - 相当于操作系统的"外壳"

------



## shell的使用方式

- 交互式  --命令行
  - 人工干预、智能化程度高
  - 逐行解释执行、效率低
- 非交互式 --脚本
  - 需要提前设计、智能化难度大
  - 批量执行、效率高
  - 方便再后台运行

------



## bash基本特性

- TAB键补全
- 历史命令
- 快捷键
- 支持别名
- 管道
- 重定向
- 标准输入输出

----------

## shell脚本概述

- 什么是shell脚本？

  - 提前写好可执行语句，能够完成特定任务的文件
  - 顺序、批量化处理

  ```shell
  [root@svr7 ~]# cat /etc/shells   //查看所有解释器
  [root@svr7 ~]# sh   //切换成sh解释器
  sh-4.2# ls    //利用sh解释器输入命令
  sh-4.2#exit   //退出sh解释器
  [root@svr7 ~]#yum -y install ksh   //安装新解释器
  [root@svr7 ~]#ksh   //进入新解释器
  
  ```

-----

#### 脚本创建"三步走"

1. 新建文本文件
2. 添加可执行的脚本语句(命令行)
3. 添加x执行权限（或使用解释器/source命令）

-----------

#### 脚本编写规范

- 声明解释器（使用哪种解释器）

  `#!/bin/bash`

- 注释，内容可以是脚本的功能、作用等介绍（或者是步骤、思路、用途、变量含义等）

  `#这是一个测试脚本`

- 执行指令

  `所有需要脚本执行的任务都可以逐行写在这里`

-------------

#### 脚本执行方式

1. 使用路径指向一个具有X权限的文件
2. 使用解释器，无需X权限，新开启解释器**子进程**

```shell
[root@svr7 opt]# bash test01.sh
nb
```

3. 使用source命令，无需X权限，**不会开启解释器**

```shell
[root@svr7 opt]# source test01.sh
nb
```

   ```shell
   [root@svr7 opt]# cat test01.sh    //可以利用该脚本测试，bash执行时看不到进入abc的效果，因为bash开启了子进程，执行完任务就退出了，父进程并没有进入abc目录，如果使用source执行该脚本就可以看到进入abc目录的效果，因为是父进程亲自进入没有开启子进程。  另外开一个命令行窗口使用pstree命令可以看到具体过程
   #!/bin/bash
   #这是一个测试脚本
   echo nb
   mkdir abc
   cd abc
   sleep 1000
   ```

----------

   

###### 编写部署网站的脚本，测试时需要临时关闭防火墙

```shell
#!/bin/bash
#部署网站服务
yum -y install httpd
echo "web~test~~~~~!!" > /var/www/html/index.html
systemctl restart httpd

```

----------------
###### 编写部署ftp的脚本,要求是开启服务的状态，并且开机自启
```shell
#!/bin/bash
#部署ftp服务
yum -y install vsftpd &> /dev/null
systemctl restart vsftpd
systemctl enable vsftpd
```

------

## shell变量

- 常量：固定不变的内容

- 变量：以固定名称存放，可能会变化的值

- - 提高脚本对任务需求、运行环境变化的适应能力

  - 方便在脚本中重复使用

-------

### 定义/赋值/查看/取消变量

- 定义/赋值变量

- - 变量名=变量值
  - 自定义变量，定义名称时可以用数字、大小写字母下划线
  - 不允许使用数字开头，不允许使用特殊字符

 

```shell
[root@localhost opt]# a=10  定义变量(赋值)
```

- 查看变量

- - 引用变量值：$变量名

  - 查看变量值

  - - echo $变量名
    - echo ${变量名}  #变量名易混淆时，以{}界定

```shell
[root@localhost opt]# echo $a 调用变量
echo ${a}RMB  容易发生混淆的情况使用大括号
```

- 取消变量（变量的失效）

- - 退出定义变量的shell环境时，变量会自动实效

  - 也可手动取消

  - - unset 变量名

```shell
[root@localhost opt]# unset a 取消变量的定义
```

------------

### 变量的种类

- 存储类型（了解）

- - 整数型、浮点型、双精度浮点型、字符型……

- 使用类型

| **类型**   | **说明**                                                     |
| ---------- | ------------------------------------------------------------ |
| 环境变量   | 变量名通常都大写，由系统维护，用来设置工作环境，只有个别用户可以直接更改 |
| 位置变量   | bash内置，存储执行脚本时提供的参数                           |
| 预定义变量 | bash内置，一类有特殊用途的变量，可直接调用但不能直接赋值或修改 |
| 自定义变量 | 由用户自主设置、修改及使用                                   |

----------

#### 环境变量

由系统提前定义好，使用时直接调用，无需用户定义

- 配置文件
  - /etc/profile
  - ~/.bash_profile

- 相关操作
  - -env  #列出所有的环境变量
  - -set  #列出所有变量

- 常见的环境变量

| USER   | 当前用户名           |
| ------ | -------------------- |
| HOME   | 当前用户的家目录     |
| UID    | 当前用户的id号       |
| SHELL  | 当前用户的解释器     |
| PWD    | 当前位置             |
| PATH   | 存储了执行指令的路径 |
| PS1    | 一级提示符           |
| PS2    | 二级提示符           |
| RANDOM | 生成一个随机数值     |
| ……     | ……                   |

-------

#### 预定义变量与位置变量

- 用来保存脚本程序的执行信息
  - 直接使用这些变量
  - 不能直接为这些变量赋值

| 变量名 | 含义                                         |
| ------ | -------------------------------------------- |
| $1     | 执行脚本名称后面的第1个位置参数              |
| $2     | 执行脚本名称后面的第2个位置参数              |
| $3     | 执行脚本名称后面的第3个位置参数              |
| $*     | 所有的位置参数                               |
| $#     | 所有的位置参数的个数                         |
| $$     | 当前运行进程的PID号                          |
| $?     | 判断上一条指令是否执行成功，0是成功非0是失败 |

###### 编写脚本，可以创建用户abcd ，并且配置密码123456

```shell
#!/bin/bash
useradd abcd 
echo 123456 | passwd --stdin abcd 
```

改良版本，使用变量

```shell
#!/bin/bash
useradd $1  //创建用户时调用第1个位置变量
echo "$2" | passwd --stdin $1 //配置密码时调用第2个位置变量
```

---------

### 变量的扩展赋值操作

#### 单引号 

- 界定范围 

- 禁用扩展，可以转义特殊符号（即便$也视为普通字符）

```shell
touch ‘a b’ 可以创建a空格b的文件
a=10
echo ‘$a’ 无法调用变量，$是调用变量的特殊符号，其效果被屏蔽
```

#### 双引号

- 界定范围
- 允许扩展，不屏蔽特殊符号（以$引用其他变量）

```shell
Touch “a b” 也可以创建a空格b的文件
echo “$a” 可以调用变量
```

 

#### 反撇号       $()

- 获取指令的执行结果(将命令的执行输出作为变量值）

```shell
a=date  定义变量时如果使用命令则不会直接识别
a=`date`  使用反撇号可以将命令的执行结果赋值给变量
a=$(date) 效果同上
```

----------

### read标准输入取值

使用read指令，可以将脚本编程交互式，使脚本可以从用户处得到信息

- read从键盘读入变量值并完成赋值
  - 用法：read -p  "提示信息"  变量名
  - -p可选
  - -t 可指定超时秒数
- 终端显示控制
  - -stty -echo		//关闭终端输出（不显示用户输入内容）
  - -stty echo          //恢复终端输出（显示用户输入内容）

###### 编写创建用户名和密码脚本

```shell
#!/bin/bash
read -p "请输入用户名："  u
useradd $u
read -p "请输入密码："  p
echo $p | passwd --stdin $u
```

改良后，输出密码时屏蔽显示

```shell
#!/bin/bash
read -p "请输入用户名："  u
useradd $u
stty -echo
read -p "请输入密码："  p
stty echo
echo "$p" | passwd --stdin $u
```

### 变量的作用范围

**局部变量**

- 新定义的变量默认只在当前shell环境中有效
- 无法在子shell环境中使用

**全局变量**

- 全局变量在当前shell及子shell环境中均有效

- 使用export可将局部变量声明为全局变量

- export 定义全局变量，可以让子进程使用父进程定义的变量

- - export -n 变量名  #取消变量的全局效果
  - export 局部变量名[=变量值].. ..  #为局部变量添加全局属性

```shell
export  b=20   创建变量b的同时发布为全局效果
export  a  将已有的变量发布为全局效果
export  -n  a  取消变量的全局效果
```

### shell中的运算

#### 基本运算类别

四则运算

加法： num1 + num2

减法： num1 - num2

乘法： num1 * num2

整除： num1 / num2

取余数运算

求模： num1 %        num2

 

#### expr运算工具

计算指定的表达式，并输出结果

- 格式：expr 整数1 运算符 整数2 …

- 乘法操作应采用 \* 转义，避免被作为shell通配符

- expr 可以计算并输出，运算符号两边要有空格

| expr  3 – 1    | 减法                                                         |
| -------------- | ------------------------------------------------------------ |
| expr 2 +   2   | 加法                                                         |
| expr 2 '*'   2 | 乘法                                                         |
| expr 2 \*   2  | 使用乘法时，这里使用\代表转义符号<br />可以屏蔽之后1个字符的特殊效果 |
| expr 4  /   2  | 除法                                                         |
| expr 10 %   3  | 取余数                                                       |

#### $[]算式替换

- 格式：$[整数1 运算符 整数2     .. ..]
- 乘法操作*无需转义，运算符两侧可以无空格
- 计算结果替换表达式本身，可结合echo命令输出

```shell
echo $[1+1]
echo $[2-1]
echo $[2*2]
echo $[4/2]
echo $[5%3]
```

 #### bc 计算器

- 可以进行小数运算

- 支持高精度的数值运算
- 直接运行bc可进入交互式运算界面，quit退出
- 设置scale=n 可约束小数位

- 结合管道向bc发送表达式

  - 多个表达式以分号分隔
  - 通过echo命令+管道传递要计算的表达式

 ```shell
echo "1.1+1" | bc  //非交互的方式使用bc工具

echo "10/3" | bc

echo "scale=3;10/3" | bc  //scale可以定义小数点后面的长度
 ```

#### 变量的自增/减等操作

使用$[ ]替换，或者let命令完成

- 结合echo命令查看结果

  使用let指令不输出计算结果，专用于创建变量，或者对变量进行自增减

用法一：创建变量

```shell
let a=1+1  创建变量a
```

用法二： 变量的自增减

| **简写表达式** | **完整表达式** |
| -------------- | -------------- |
| i++            | i=i+1          |
| i--            | i=i-1          |
| i+=2           | i=i+2          |
| i-=2           | i=i-2          |
| i*=2           | i=i*2          |
| i/=2           | i=i/2          |
| i%=2           | i=i%2          |

常规写法         主流写法

let a=a+1           let a++  变量的自增减，将变量a的值加1

let a=a-1            let a--  变量a减1

let a=a+2           let a+=2  变量a加2

let a=a-2            let a-=2  变量a减2

let a=a\*10         let a*=10 变量a乘以10

 

let x=x+1           let x++        //把x+1

let x=x-1            let x—         //把x-1

let x=x+3           let x+=3      //把x+3 

let x=x\*3           let x*=3      //把x乘以3

let x=x/2            let x/=2       //把x除以2

let x=x%3          let x%=3     //用x除3取余数

#### 小数值的比较

基本用法

- echo "数值1 比较符 数值2"       | bc

  如果表达式成立，则返回的计算结果为1，否则返回0

  常见比较操作： 

  - - \>
    - \>=
    - < 
    - <=
    - ==
    - !=

-----

## 条件测试

可以为脚本提供智能判断的效果

使用方式： test 表达式       或  **[表达式]**

#### 条件测试种类
##### 对字符串进行判断

  - ==		//两边是否相等
  - !=          //两边是否不等

[ a == a ]                  判断字符串a是否等于a，如果相等，返回值就是0
[ root == $USER ]   判断当前用户名是否叫root，如果是，返回值就是0
[ root != $USER ]    判断当前用户名是否不叫root，如果不叫root，返回值就是0
[ -z $a ]                    判断变量a是否为空，如果是，返回值是0
[ ! -z $a ]                  判断变量a是否非空，如果是，返回值是0

##### 逻辑符号

- &&		//之前任务执行成功，执行后者
- ||           //之前任务执行失败，执行后者

```shell
[ root == $USER ] || exit   //如果当前用户不是管理员，则退出
```

```shell
ls || ls   					//只执行第1个ls
```

```shell
ls && ls  					//两个ls都执行
```

- 逻辑符号的组合应用

当2个逻辑符号连用时，第二个逻辑符号后面的任务是否执行不能只看前一个任务，要看前面所有任务的组合。

如：

```shell
touch a b c	创建3个测试文件

ls a && ls b && ls c    
都显示，第一个ls执行成功，然后导致第二个ls也执行，并且可以成功，这样的话第一个和第二个任务都成功了，那么这个组合就算成功，然后会导致第二个逻辑符号&&后面的ls c 也执行并且成功。

ls a && ls b || ls c     
显示a和b，第一个ls执行成功，然后导致第二个ls也执行，并且可以成功，这样的话第一个和第二个任务都成功了，那么这个组合就算成功，但是由于第二个逻辑符号是||，就不会执行最后的ls c任务了

ls a || ls b && ls c     
显示a和c，第一个ls执行成功，第二个ls就不会执行了，这两个任务中间是|| ，那么只要有一个成功就算这个组合执行成功，所以就会导致第二个逻辑符号&&后面的ls c执行

ls a || ls b || ls c      
显示a，第一个ls执行成功，第二个ls就不会执行了，这两个任务中间是|| ，那么只要有一个成功就算这个组合执行成功，由于这个组合算成功，所以就不会执行第二个||后面的任务了
```

###### 案例

编写脚本安装ftp服务，但如果是非管理员执行该脚本则给出非管理员的提示并退出

```shell
#!/bin/bash
[ root != $USER ]  &&  echo "你不是管理员"  &&  exit
yum -y install vsftpd
systemctl restart vsftpd
systemctl enable vsftpd
```

##### 数字的条件测试

-eq	是否相等

-ne	是否不等

-gt	大于

-ge	大于等于

-lt	小于

-le	小于等于

```shell
[ 1 -eq 1 ] 
//判断1是否等于1，判断成功的话返回值是0，判断失败返回值是非0
a=10	   
b=20
[ $a -eq $b ] && echo "ok" || echo "no" 
//判断变量a是否等于b ，是的话显示ok，否显示no
[ $a -gt $b ] && echo "ok" || echo "no" 
//判断变量a是否大于b ，是的话显示ok，否显示no
```



###### 综合案例1：编写监控脚本，每2分钟检查服务器登录的用户数量如果超过3人，就给管理员发报警邮件

```shell
#!/bin/bash
x=$(who | wc -l)
[ $x -gt 3 ] && echo "有人入侵服务器！n老师扛着铁锤来了！！"  | mail -s test root
```

脚本写完后，执行下列指令：
```shell
rm -rf /var/spool/mail/root   清空邮箱(非必须)
[root@svr7 opt]#chmod +x test01.sh   给脚本添加执行权限
[root@svr7 opt]# crontab -e   编写计划任务
*/2 * * * * /opt/test01.sh     每2分钟执行脚本
```

然后故意多登陆几个账户，每2分钟就可以收到新邮件

##### 对文件进行条件测试
-e	 是否存在，不关心文件类型
-f	  是否存在，且是普通文件
-d	 是否存在，且是目录
-r	  判断当前用户对文件是否能读 ，对root无效
-w	判断当前用户对文件是否能写 ，对root无效
-x	 执行(文件)，进入(目录)

[  -e  a  ]    当前位置如果有a文件，不关心类型，则测试成功
[  -f  a  ]     当前位置如果有叫a的普通文件，则测试成功
[  -d  a  ]    当前位置如果有叫a的目录，则测试成功
[  -r  a  ]     当前用户如果对a文件有读权限，则测试成功
[  -w  a  ]    当前用户如果对a文件有写权限，则测试成功
[  -x  a  ]     当前用户如果对a文件有执行(目录是进入)权限，则测试成功

## IF选择结构

>  虽然&&和||可以实现逻辑组合
>
> 但如果情况比较复杂就可能需要n多个&&或者||
>
> 会导致脚本难写，可读性差。此时就可以使用if分支

if分支由三种：

### 1. if单分支结构

- 当"条件成立"时执行命令序列
- 否则，不执行任何操作

```shell
if 条件测试; then		//如果条件测试成功，执行下面的指令
		指令1
		指令2
		……
fi
```

### 2. if双分支结构

- 当"条件成立"时执行命令序列1
- 否则，执行命令序列2

```shell
if 条件测试; then		//如果条件测试成功，那就执行下面的指令
	指令1
	指令2
	……
 else				   //如果上述条件测试失败，那就执行下面的指令
 	指令3
 	指令4
 	……
fi
```

###### ping命令应用在脚本中可以使用的选项

ping -c		//ping的次数

​		 -i		//ping间隔时间单位（秒）

​		 -W	   //如果ping不通，多久反馈结果（秒）

> ping -c 3 -i 0.1 -W 1     192.168.4.7

###### 案例：编写脚本测试某ip是否能ping通，但不要显示过程，仅仅显示通了或者不通即可

```shell
ping -c 3 -i 0.1 -W 1 192.168.4.7 &> /dev/null    
//ping的具体过程扔黑洞不看
    if [ $? -eq 0 ];then	 //仅仅使用$?可以判断上面的任务是否成功，如果等于0就是成功
        echo "通了"
    else
        echo "不通"
    fi
```

-----------

### 3. if多分枝结构

- 相当于if语句嵌套
- 针对多个条件分别执行不同的操作

```shell
if 条件测试; then		//首先判断，条件测试成功，就执行1、2
	指令1
	指令2
elif 条件测试; then		//上述测试失败，此处测试成功的话就执行指令3、4
	指令3
	指令4
else				//上述测试都失败的话就执行指令5、6
	指令5
	指令6
	……
fi
```

## 循环结构

有时我们需要某个或者某群任务反复在服务器中执行很多次，就可以使用循环命令写成脚本，而无需手工一次次执行

### for循环

<u>可以定义循环次数，有限的循环</u>

- 遍历/列表式循环
  - 根据变量的不同取值，重复执行命令序列

> 此处变量名可自定义，通常习惯用i
>
> 值的多少决定了下面do与done之间的任务执行多少次
>
> 每个值之间有空格

```shell
for 变量名 in 值列表（值1、值2、值3……)	
do
	指令
done
```

示例1

```shell
#!/bin/bash
for i in a b c     //给了abc三个值，下面的echo任务就循环三次
do
   echo "nb"
done
```

示例2

```shell
#!/bin/bash
for i in {1..100}  循环100次时无需填写100个值，用此格式即可，代表1到100，一共100个值，但不支持变量   
do
   echo "nb"
   echo "$i"    执行任务时，还可以调用变量，变量的值是所有值的轮询，由于这里给了1到100的值，那第一次循环$i就是1，第二次循环$i就是2，依次类推到第100次循环$i就是100
done
```

示例3

```shell
#!/bin/bash
a=100
for i in $(seq $a)  循环100次，支持变量，seq命令可以帮我们创建数字序列，对于for循环来说，就是可以当是多个值
do
   echo "nb"
   echo "$i"
done
```

###### 案例：编写脚本，测试192.168.4.1~192.168.4.15能否ping通，并且统计多少台通了，多少台不通

```shell
#!/bin/bash
x=0		//定义通了的数量
y=0     //定义没通的数量
for i in {1..15}    //循环15次
do
    ping -c 3 -i 0.1 -W 1 192.168.4.$i &> /dev/null    //每次循环$i的值就从1往后轮询
    if [ $? -eq 0 ];then
        echo "4.$i 通了"
        let x++    //每通了一次就把x+1
    else 
        echo "4.$i 不通"
        let y++    //每不通一次就把y+1
    fi
done
echo "通了$x台，不通$y台"     //最后喊出结果
```

-----------

### while循环

<u>可以根据条件测试决定循环次数，可以实现无限循环</u>

- 条件式循环
  - 反复测试条件，只要成立就执行命令序列
- 无限循环表达方法
  - while :     //冒号代表测试永远正确

> 如果条件测试得到成功的结果就执行下面的指令
>
> 然后再回来继续看条件测试能否成功
>
> 如果成功就继续执行指令
>
> 且可以实现无限循环
>
> 一旦发现条件测试失败了，就立刻终止循环

```shell
while 条件测试	
do
	指令
done
```

示例1：无限输出文本

> 注意！如果系统执行任务小号cpu较多，可以在循环中加入sleep命令，
>
> 以缓解cpu占用压力

```shell
while :			//冒号代表测试永远正确
do
    echo nb		//循环任务
    sleep 0.1    //如果系统执行任务消耗cpu比较多，可以每次稍微休息一下
done
```

###### 案例：使用while编写猜数字脚本

```shell
#!/bin/bash
x=$[RANDOM%100]    //RANDOM是可以得到随机数的变量，除以100取余数可以得到零到99之间的随机数，并且存到变量x中
y=0     //这里还可以定义猜的次数，一次没猜时是0次
while :     //无限循环
do
let y++    //每猜一次，把y+1
read -p "请输入一个整数(0-99):" n        //将用户给的数字存到变量n中
if [ $n -eq$x ];then      //使用if多分枝加条件测试判断n是否等于x
        echo "恭喜！猜对了！猜了$y次"     //如果n等于x就喊出这句话
        exit
elif [ $n -gt $x ];then			//如果n比x大
        echo "猜大了！"
else							//还有最后一种情况
        echo "猜小了！"
fi
done
```

-----

## CASE语句

<u>功能类似if，不如if强大，但是语法比较精简</u>

- 检查变量的**实际**取值
  - 如果与预设的值匹配，则执行对应的操作

```shell
case 调用变量名 in 	
模式1)			//这里模式可以有多个，用|分隔
	执行指令;;		//必须双分号结尾，如果多个指令，在最后一个添加
模式2)
	执行指令;;
……
*)			//如果上述模式都没有被匹配，那就匹配这个
	执行指令
esac
```

示例1：编写脚本，实现脚本创建目录/文档，删除文件

```shell
#!/bin/bash
case $1 in		//使用执行脚本后的第1个位置变量作为匹配对象
t|T|tt)			//如果$1是t或者T或者tt，都可以算匹配
    touch $2;;	 //此处是创建文件的命令，后面是第二个位置变量的参数
m|M|mm)
    mkdir $2;;
r)
    rm -rf $2;;
*)
    echo "请输入t|m|r"
esac
```

###### 案例：编写脚本，部署Nginx服务

> httpd是之前使用过的网站服务，除此之外nginx也可以实现搭建网站的任务

编写部署nginx服务的脚本思路：

1）安装依赖 gcc(编译工具)，pcre-devel，openssl-devel(后两个都是nginx所需依赖包)
2）释放nginx-1.17.6.tar.gz
3）进入nginx-1.17.6目录
4）./configure    配置
5）make     编译
6）make install   安装

1. 将lnmp_soft.tar.gz软件包传到管理员家目录，然后释放

```shell
[root@svr7 ~]# tar -xf lnmp_soft.tar.gz  //释放到当前目录  
[root@svr7 ~]# cd lnmp_soft/    //然后到释放的目录中
[root@svr7 lnmp_soft]# cp nginx-1.17.6.tar.gz /opt    //将nginx拷贝到opt下
```

2. 安装nginx

由于nginx是源码包，所以需要源码编译安装

```shell
#!/bin/bash
yum -y install gcc pcre-devel openssl-devel &> /dev/null     //安装依赖软件包
tar -xf nginx-1.17.6.tar.gz		//释放tar包
cd nginx-1.17.6     //进入nginx目录
./configure      //配置
make      //编译
make install    //安装
```

写完后保存退出，并执行脚本

```shell
systemctl  stop  httpd    //之后关闭其他网站服务
/usr/local/nginx/sbin/nginx     //开启nginx服务
/usr/local/nginx/sbin/nginx -s stop    //关闭nginx服务
systemctl stop firewalld		//关闭防火墙
```

然后使用浏览器访问192.168.4.7可以看到欢迎界面则成功

###### 案例：编写脚本，使用case分支控制nginx服务

```shell
#!/bin/bash
case $1 in		//使用执行脚本后的第1个位置变量作为匹配对象
s|start|kai)   //如果$1是s或start或kai ，那么就执行以下指令
    netstat -ntulp | grep -q nginx   //查询有没有开启nginx服务, -q是不输出查询结果
    [ $? -eq 0 ] && echo "nginx已经开启" && exit     //判断如果开了nginx就退出
    /usr/local/nginx/sbin/nginx;;     //如果没开nginx就开启
stop|guan)    //如果$1是stop或guan，那么就执行以下指令
    /usr/local/nginx/sbin/nginx -s stop;;     //关闭nginx
restart|cq)    //如果$1是restart或cq，那么就执行以下指令
    /usr/local/nginx/sbin/nginx -s stop   //关闭nginx
    /usr/local/nginx/sbin/nginx;;    //开启nginx，此处相当于重启nginx
status|cx)     //如果$1是status或cx，那么就执行以下指令
    netstat -ntulp | grep -q nginx  //查询有没有开启nginx服务, -q是不输出查询结果
    [ $? -eq 0 ] && echo "nginx正在运行中。。"  || echo "nginx未开启";;   //根据查询结果输出nginx正在运行或者nginx未开启的提示
*)
   echo "start|stop|restart"    //如果没有匹配任何模式就是喊出使用该脚本的提示，告诉使用者$1应该敲啥，而不能随意敲。
esac    //结尾，固定语法，不能少
```

## netstat命令

可以查看系统中启动的端口信息，该命令常用选项如下：

-n	以数字格式显示端口号
-t	 显示TCP连接的端口
-u	显示UDP连接的端口
-l	 显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p	显示监听端口的服务名称是什么（也就是程序名称）

---------

## 修改文字的颜色

如果想在nginx中修改输出文字的颜色，可以使用下列方式：

```shell
echo -e "\033[32mABCD\033[0m"     
```

-e选项可以激活后面特殊字符的作用，相当于使用echo的扩展功能

\033[32m代表设置颜色为绿色

ABCD是输入内容

\033[0m代表还原颜色。

-------

## shell 函数

函数：

在shell环境中，将一些需要重复使用的操作，定义为公共的语句块，可称为函数

好处：

精简脚本，增强可读性，方便反复使用

格式1（不常用）：

```shell
function  函数名 {
	命令序列
	……
}
```

格式2（主流用）：

```shell
函数名() {
	命令序列
	…………
}
```

示例1：定义函数a，执行多任务

```shell
#!/bin/bash
a() {          //定义函数
echo abc
echo xyz
}
a    //调用函数，相当于执行上述两个echo任务
a    //可以反复调用
```

示例2：定义函数a，调整输出不同颜色的文本

```shell
#!/bin/bash
a() {                //定义函数
echo -e "\033[$1m$2\033[0m"     //输出不同颜色的文本内容，并加入位置变量
}
a 31 ABCD    //调用时函数后面可以写位置变量的内容，31就是$1  ABCD是$2
a 32 XUEY 
```

## 循环的控制:中断/继续/退出

通常，在执行循环任务中途如果想退出可以用exit指令

但该指令不但会退出循环，连同脚本也会一并退出

此时可以使用break与continue指令更精细的控制循环

exit   	   // 可以终止循环，但同时退出脚本，如果循环之后还有任务则无法执行
break       //终止循环，继续执行循环之后的任务
continue    //终止当前循环，继续执行下一次循环

###### 案例：编写脚本，可以为用户进行整数求和，如果输入0则退出并显示之前求和结果

```shell
#!/bin/bash
x=0		//先定义了一个x，表示用户给的整数之和，一个都没给时就是0
while :
do
read -p "请输入一个整数求和，0是结束" n    //问用户要数字
[ -z $n ] && continue		//如果n是空值，就重新循环
[ $n -eq 0 ] && break	//如果n是0，就退出循环
let x+=n     //将x+n
done
echo "整数之和是$x"    //喊出结果
```



## 字符串处理

### 字符串的截取

- 使用 $P{}表达式

格式： ${var:起始位置:长度}

> 起始位置：编号从0开始，可省略

```shell
x=abcdef
echo ${x:1:2}  //截取bc，位置是从0开始计算
echo ${x:1:1}  //从第2个字符截取，截取1位
echo ${x:0:2}   //从第1个字符截取，截取2位
echo ${x::2}   //效果同上，如果从第1位开始截取的话，0可以省略不写
```

###### 案例：编写脚本，可以获取随机的8位字符

**将来可以作为为用户配置随机密码时使用！**

```shell
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789    //定义变量
for i in {1..8}     //循环8次
do
n=$[RANDOM%62]   //得到0-61之间的随机数
a=${x:n:1}   //随机截取一个x中的字符存储到变量a中
pass=$pass$a  //将每次获取的随机字符存储到变量pass中
done
echo $pass   //循环完8次之后，喊出最终结果，就得到了1个8位的字符
```

###### 案例：创建30个10位的密码，存放到一个文件中

```shell
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
for j in {1..30}		//将得到10位随机字符的过程执行30次
do
    for i in {1..10}    //将得到1个随机字符的过程执行10次
    do
        n=$[RANDOM%62]   //得到0-61之间的随机数
        a=${x:n:1}    //随机截取一个x中的字符存储到变量a中
        pass=$pass$a    //将每次获取的随机字符存储到变量pass中
    done
echo $pass >> /opt/pass.txt  //将每次得到的10位字符追加保存到pass.txt中
    pass=   //清空pass变量，避免下次叠加
done
```

### 字符串的替换

- 只替换第1个匹配结果

格式： ${var/old/new}

- 替换全部匹配结果

格式：${var//old/new}

```shell
a=1234		//定义素材
echo ${a/3/6}    //把3换成6
a=11223344    //定义素材
echo ${a/3/6}    //把3换成6,默认只换一个
echo ${a//3/6}   //使用两个/可以实现把所有3换成6
a=333444     //定义素材
echo ${a//3/}   //把所有3换成空，相当于删除
```

### 字符串的删除（掐头去尾）

​	${变量名#删除的内容}		//从左到右删除

​	${变量名%删除的内容}		//从右到左删除



​	${变量名##删除的内容}		//从左到右删除到最后一个匹配的关键词

​	${变量名%%删除的内容}		//从右到左删除到最后一个匹配的关键词

```shell
a=abcdefghijklmn
echo ${a#abcdefgh}	 //从左往右删除到h
echo ${a#*h}		//效果同上，更精简
echo ${a#ab}  //从左往右删除到b
echo ${a#*b}  //效果同上，更精简

a=abcxyzabcxyz  
echo ${a##*b}   //从左往右删除到最后一个b

a=abcxyzabcxyz
 echo ${a%abcxyz}   //从右往左删除abcxyz
 echo ${a%a*}    //效果同上，更精简
 echo ${a%%a*}   //从右往左删除到最后一个a
 echo ${a%%y*}   //从右往左删除到最后一个y
```

案例：编写脚本，实现批量修改文件的扩展名

```shell
touch abc{1..10}.txt   //创建10个文件作为素材

#!/bin/bash
for i in $(ls *.txt)		//找到所有txt文件交给for循环
do
        n=${i%.*}   //先用去尾删除扩展名
        mv $i $n.doc   //再将原文件修改为doc扩展名
done
```

## 变量初值（备用值）

${变量名:-初值}	//如果变量有值则使用本身的值，如果变量为空，则使用初值

###### 案例：编写脚本，可以创建用户与配置密码

密码可以自定义，也可以使用默认的123456

```shell
#!/bin/bash
read -p "请输入用户名：" n
useradd $n
read -p "请输入密码："  p
echo ${p:-123456} | passwd --stdin $n  //当用户没有输入密码时
密码就是123456 				
```

-------

## 正则表达式 

<u>**使用若干符号配合某工具实现对文档的过滤、查找、修改等功能**</u>

以/etc/passwd为素材，如下：

```shell
grep bin user   //找有bin的行
grep ^bin user	//找以bin开头的行
grep bash user   //找有bash的行
grep bash$ user   //找以bash结尾的行

vim user     //编辑文档添加空行
grep  -n  ^$  user   //找空行，加n选项可以显示行号

grep "[root]" user   //找root四个字符任意一个
grep "[rot]" user	  //效果同上，找rot任意一个字符
grep "rot" user   //找连续的rot字符串
grep "[a-z]" user   //找所有小写字母
grep "[A-Z]" user   //找所有大写字母
grep "[a-Z]" user   //找所有字母
grep "[0-9]" user   //找所有数字
grep "[^a-Z]" user  //找字母之外的内容，^写在[]里是取反效果

grep "r..t" user   //找rt之间有2个任意字符的行
grep "r...t" user  //找rt之间有3个任意字符的行		
grep "*" user  //*号是匹配前一个字符任意次，不能单独使用
grep "ro*t" user  //找rt，中间的o有没有都行
grep "." user   //找任意单个字符
grep ".*" user  //找任意   

grep "ro\{2,4\}t" user   //找rt，中间的o可以是2~4个
grep "ro\{2,\}t" user	//找rt，中间的o可以是2个以及2个以上
grep "ro\{3,7\}t" user //找rt，中间的o可以是3~7个，没有匹配条件就没有任何显示
grep "ro\{3,\}t" user  //找rt，中间的o可以是3个以及3个以上
grep "ro\{2\}t" user  //找rt，中间的o必须是2个
 
grep "ro\{1,\}t" user    //找1次以及1次以上的o
egrep "ro{1,}t" user   //效果同上
egrep "ro+t" user     //效果同上，最精简

grep "roo\{0,1\}t" user   //第二个o要出现0~1次
egrep "roo{0,1}t" user  //效果同上
egrep "roo?t" user   //效果同上，最精简

grep "ro\{2\}t" user    //找o出现2次的
egrep "ro{2}t" user    //效果同上

egrep "^root|^bin" user   //找root或者以bin开头的行
egrep "^(root|bin)" user   //效果同上
egrep "\bthe\b" abc    	//找the，前后不允许出现数字，字母，下划线

```

### 正则表达式整理表

行首尾及单字匹配

| **类型** | **含义** | **示例** | **说明**                       |
| -------- | -------- | -------- | ------------------------------ |
| ^        | 匹配行首 | ^abc     | 以abc开头的行                  |
|          |          | ^#       | 以#号开头的行（比如注释行）    |
| $        | 匹配行尾 | abc$     | 以abc结尾的行                  |
|          |          | ^$       | 空行                           |
| .        | 单个字符 | .        | 除换行符(\n)以外的任意单个字符 |

未定匹配次数

| **类型** | **含义**     | **示例** | **说明**             |
| -------- | ------------ | -------- | -------------------- |
| +        | 最少匹配一次 | a+       | 一个或多个连续的a    |
|          |              | (abc)+   | 一个或多个连续的abc  |
| ?        | 最多匹配一次 | a?       | 0个或1个a            |
|          |              | (abc)?   | 0个或1个abc          |
| *        | 匹配任意次数 | a*       | 0个或多个连续的a     |
|          |              | (abc)*   | 0个或多个连续的abc   |
|          |              | .*       | 任意长度的任意字符串 |

| **类型** | **含义**    | **示例**  | **说明**              |
| -------- | ----------- | --------- | --------------------- |
| {n}      | 匹配n次     | (ab){3}   | 匹配ababab            |
| {n,m}    | 匹配n-m次   | (ab){1,3} | 匹配ab、abab、ababab  |
| {n,}     | 匹配至少n次 | (ab){2,}  | 匹配2个及以上连续的ab |

- []范围内单字匹配

- - 匹配制定字符集合内的任何一个字符

  - - []内加^可取反

| **示例**  | **说明**                 |
| --------- | ------------------------ |
| [alc45_?] | 匹配a\l\c\4\5\_\?        |
| [a-z]     | 匹配任意小写字母         |
| [A-Z]     | 匹配任意大写字母         |
| [0-9]     | 匹配任意数字             |
| [a-Z0-9]  | 匹配任意字母或数字       |
| \[^A-Z]   | 匹配包括非大写字母的行   |
| ^\[^a-z]  | 匹配不以小写字母开头的行 |

整体及边界匹配

| 类型 | **含义**       | **示例**  | **说明**                                           |
| ---- | -------------- | --------- | -------------------------------------------------- |
| ()   | 组合为整体     | ab{1,3}   | 匹配ab,abb,abbb                                    |
|      |                | (ab){1,3} | 匹配ab,abab,ababab                                 |
| \|   | 或者           | root\|bin | 匹配root、bin                                      |
| \b   | 单词边界       | \broot\b  | 匹配单词rooot、不匹配keroot、rooty、brooty等字符串 |
| \<   | 单词的开头     | \<th      | 匹配以th开头的单词                                 |
| \>   | 单词的结束     | \<root\>  | 作用与\broot\b相同                                 |
| \w   | 字母数字下划线 | \wa       | 匹配xa,不匹配#a                                    |
| \s   | 匹配空白       | \sa       | 匹配 a,不匹配xa                                    |
| \d   | 匹配数字       | -p\da     | 匹配5a,不匹配xa                                    |

---------

## LINUX三剑客(处理字符）

- grep  -----模糊搜索
- sed   -----（也算模糊搜索）非交互式对文档对文档进行增删改查
- awk   -----精确搜索

-----------

## sed

### sed工具概述

- Stream Editor ，流式编辑器

- - 非交互，基于模式匹配过滤及修改文本
  - 逐行处理，并将结果输出到屏幕
  - 可实现对文本的输出，删除，替换，复制，剪切，导入，导出等操作
  - vim能干的事儿sed都能干

### 命令格式解析

- 主要用法

1. 前置命令 | sed     选项 定址符 '指令'
2. sed 选项 '定址符 指令' 被处理的文档

- 常见命令选项

- - -n： 屏蔽默认输出（全部文本）
  - -i：直接修改文件内容（写入文件）
  - -r：支持扩展正则（若与其他选项一起使用，应作为首选项）

- 常见指令

- - p 输出
  - d 删除
  - s 替换

#### sed的输出

| **操作符** | **用途**   | **指令示例**                           |
| ---------- | ---------- | -------------------------------------- |
| p          | 打印行     | 2,4p 输出2,3,4行                       |
|            |            | 2p;4p 输出第2,4行                      |
|            |            | 2,+1p 输出第2,3行                      |
| d          | 删除行     | 2,4d 删除第2,3,4行                     |
| s          | 字符串替换 | s/old/new  将每行的第1个old替换为new   |
|            |            | s/old/new/3  将每行的第3个old替换为new |
|            |            | s/old/new/g  将所有的old都替换为new    |

```shell
sed -n '1p' user		//输出第1行
sed -n '2p' user    //输出第2行
sed -n '3p' user    //输出第3行
sed -n '2,4p' user   //输出第2~4行
sed -n '2,+1p' user  //输出第2行以及后面1行
sed -n '2p;4p' user  //输出第2行，第4行
```

```shell
sed -n '/^root/p' user  //在sed中使用正则表达式输出以root开头的行
grep "^root" user  //效果同上

egrep "^root|^bin" user  //找root或者bin开头的行  
sed -nr '/^root|^bin/p' user  //在sed中查找，-r使用扩展正则，效果同上

sed -n '=' user    //查看所有行号
sed -n '$=' user   //查看最后一行的行号，相当于查看文档总共有几行

```
#### sed的删除
```shell
sed  '1d' user   //删第1行
sed  'd' user   //删所有
sed  '3d' user  //删第3行
sed  '2,5d' user   //删2~5行
sed  '4,+2d' user  //删4行以及后面2行
sed  '1d;3d' user   //删第1行，第3行
sed  '$d' user   //删除最后一行
sed -n '$p' user  //查看最后一行
sed -n '1!p' user   //查看除了第1行以外的行, !代表取反
```

示例：编写正则表达式匹配11位手机号

1. 准备测试文件

```shell
[root@svr5 ~]# cat tel.txt 
01012315
137012345678
13401234567
10086
18966677788
```

2. 提取包含11位手机号的行

```shell
[root@svr5 ~]# egrep '^1[0-9]{10}$' tel.txt 
13401234567
18966677788
```

#### sed的替换

准备示例文档

```shell
vim test.txt    //准备素材,写入下列内容 
2017 2011 2018
2017 2017 2024
2017 2017 2017
```

示例1

```shell
sed 's/2017/8888/' test.txt  //替换所有行的第1个2017为8888
sed '1s/2017/8888/' test.txt  //替换第1行的第1个2017
sed '2s/2017/8888/' test.txt  //替换第2行
sed '1,2s/2017/8888/' test.txt  //替换1~2行
sed 's/2017/8888/2' test.txt   //替换所有行的第2个2017
sed 's/2017/8888/3' test.txt   //替换所有行的第3个2017
sed '/2011/s/2017/8888/' test.txt  //替换有2011的行的第1个2017
sed 's/2017/8888/g' test.txt   //替换所有行的所有个
sed -n 's/root/6666/p'  /etc/passwd  //替换每行第1个root，并只显示被替换的行
sed -n 's/root/6666/2p'  /etc/passwd  //替换每行第2个root，并只显示被替换的行
sed -n 's/root/6666/gp'  /etc/passwd  //替换每行的所有root
sed '3s/2017/8888/;3s/2017/8888/' test.txt  //替换第3行的第1个和第2个2017
```

示例2：尝试将user文档中的/bin/bash替换成/sbin/sh

```shell
sed 's//bin/bash//sbin/sh/' user    //常规手段替换，内容会与替换 冲突，替换失败
sed 's/\/bin\/bash/\/sbin\/sh/' user  //使用\转义符号，可以成功，但不方便
sed 's!/bin/bash!/sbin/sh!' user   //更改替换的间隔符号是最理想方法
sed 's(/bin/bash(/sbin/sh(' user   //效果同上
```

#### 行上/下追加，替换整行

```shell
sed 'a 666' user  //在所有行下追加666
sed '1a 666' user  //第1行下追加666
sed 'i 666' user   //所有行上添加666
sed '3i 666' user  //第3行上添加666
sed '2a 666' user   //第2行下追加666
sed 'c 666' user   //所有行替换成666
sed '/root/c 666' user  //找到有root的行替换成666 
```

#### sed替换高级应用

##### 1.删除文件中每行的第二个、最后一个字符

> 分两个步骤完成，中间用分号隔开
>
> 第一步将每行的第二个任意字符替换成空
>
> 第二步将每行的最后一个任意字符替换成空即可

```shell
sed 's/.//2;s/.$//' test    
```

##### 2.删除文件中所有的数字

> 先找到任意数字，然后都替换成空

```shell
sed -i 's/[0-9]//g' test	//先找到任意数字，然后都替换成空
```

##### 3.将文件中每行的第一个、倒数第一个字符互换

```shell
echo abc > abc			//创建素材
sed -r 's/(a)(b)(c)/\3\2\1/' abc  //替换abc时复制每一个字符，后面替换的内容用\数字粘贴，可以任意调换位置
echo xyz >> abc   //追加内容
sed -r 's/(a)(b)(c)/\3\2\1/' abc  //再用之前的方法无法替换第2行
sed -r 's/(.)(.)(.)/\3\2\1/' abc  //将具体字符用 . 替代即可将文档中的xyz修改成xyaz时，上述方案失灵
sed -r 's/^(.)(.*)(.)$/\3\2\1/' abc   //再次升级，分别找到第1个字符和最后1个字符，中间可以是任意
sed -r 's/^(.)(.*)(.)$/\3\2\1/' test   //达成需求
```

##### 4.为文件中每个大写字母添加括号

> 先找到任意大写字母，然后保留，最后替换成带括号的状态

```shell
sed -r 's/([A-Z])/(\1)/g' test  //先找到任意大写字母，然后保留，最后替换成带括号的状态
```

##### 案例：编写脚本，安装httpd服务，使用82号端口

```shell
#!/bin/bash
yum -y install httpd
sed -i '/^Listen 80/s/80/82/' /etc/httpd/conf/httpd.conf   //找到有Listen 80开头的行，替换80为82
systemctl restart httpd

运行脚本之后，使用curl 192.168.4.7:82测试 或者火狐浏览器192.168.4.7:82
要关闭selinux与防火墙
setenforce 0    //如果脚本执行之前没关闭selinux，会报错
systemctl stop firewalld
```

##### 案例：找到使用bash作解释器的用户名

> 找到使用bash的用户
>
> 将用户信息中从冒号到后面的所有内容替换成空
>
> 留下的就是用户名

```shell
sed -n "/bash$/s/:.*//p" /etc/passwd  
```

##### 案例：编写脚本，找到使用bash解释器的用户--进阶

编写脚本，找到使用bash解释器的用户，并按照 “用户名 --> 密码” 的格式保存到log文件中

```shell
#!/bin/bash
u=$(sed -n '/bash$/s/:.*//p' /etc/passwd)   //找到使用bash的人，并且将这些用户的名字存到变量u中
for i in $u   //将这些人交给for循环处理
do
        u1=$(grep $i: /etc/shadow)  //用每个人名找到密码文件中shadow中对应的信息
        u2=${u1#*:}  //然后掐头
        u3=${u2%%:*}  //再去尾，得到纯粹的密码
        echo "$i --> $u3"    //再按格式输出,如果需要保存就用 >> log 
done
```

------

## awk

### 概述

awk：编程语言/数据处理引擎

创造者：Aho、Weinberger、Kernighan

基于模式匹配检查输入文本，**逐行处理**并输出

使用环境：

- 用在shell脚本中，获取指定的数据

- 单独使用时，可对文本数据作统计

### 命令格式解析

- 格式一

前置命令|awk [选项]   '[条件]{指令}'

- 格式二

awk [选项]  '[条件]{指令}'   文件……

- 常用命令选项：

  -F			//定义分隔符，可以是多个

> -F[:/]		#和/都是分隔符，同作用

- 常用指令：

  print		//输出 ，最常用指令

> 多条语句可以以;分隔

### awk内置变量

有特殊含义，可直接使用

| **变量** | **用途**                                        |
| -------- | ----------------------------------------------- |
| FS       | 保存或设置字段分隔符，例如FS=":",与-F功能一样   |
| $n       | 指定分隔的第n个字段，如$1、$3分别表示第1、第3列 |
| $0       | 当前读入的整行文本内容  ;所有列                 |
| NF       | 记录当前处理行的字段个数（列数）  ;列号         |
| NR       | 记录当前已读入行的数量（行数）  ;行号           |

```shell
awk '{print}' test.txt   //输出test所有行所有列
awk '{print $1}' test.txt  //输出test所有行第1列
awk '{print $2}' test.txt  //输出test所有行第2列
awk '/world/{print $2}' test.txt  //找到有world的行，然后输出第2列
awk '{print $0,$1}' test.txt  //找所有行的所有列和第1列
awk '{print NR}' test.txt  //输出每行的行号
awk -F: '{print $1" 的解释器是 "$7}'  user  //使用冒号作为分隔符,输出第1列，第7列，中间加常量，常量要使用双引号
```

示例1：利用awk提取本机的网络流量信息

```shell
ifconfig eth0 | awk '/RX p/{print "eth0网卡的接收流量是"$5"字节"}'
ifconfig eth0 | awk '/TX p/{print "eth0网卡的发送流量是"$5"字节"}'
```

示例2：使用awk提取根分区剩余容量

```shell
df -h | awk '/\/$/{print "根分区剩余容量是"$4}'
```

### awk处理时机

BEGIN{   }执行一次		

{   }逐行任务，执行n次

END{   }执行一次



示例：按下列格式要求输出信息

User	UID	HOME

..

..

..

```shell
awk -F: ‘BEGIN{  }{  }END{  }’  user   //首先分析，写出基本各式
awk 'BEGIN{print "User\tUID\tHome"}'  //第一个是BEGIN任务,
就是输入表头信息,\t是制表符，相当于在文档中敲tab键，可以在一定程度上让文档自动空格排列整齐
awk -F: '{print $1"\t"$3"\t"$6}' user   //第二个是逐行任务，找到用户名，id号，家目录
awk -F: 'END{print "总计"NR"行"}' user   //最后的任务是输出一共多少行，NR是变量可以显示行号，在END任务中就是显示最后一行的行号

awk -F: 'BEGIN{print "User\tUID\tHome"}   {print $1"\t"$3"\t"$6}END{print "总计"NR"行"}' user    //将上述命令敲成一行，完成需求
```

### awk中的条件

#### 使用正则

~		//包含

!~		//不包含

```shell
awk -F: '/bin/{print $1}' user    输出有bin的行的第1列
awk -F: '$5~/bin/{print $1}' user  输出第5列包含bin的行的第1列
awk -F: '$5!~/bin/{print $1}' user  输出第5列不包含bin的行的第1列
```

#### 使用数字、字符串

==

!=

\<

\>

\>=

\<=

```shell
awk -F: 'NR==3{print}' /etc/passwd  输出第3行
awk -F: '$3<10{print}' /etc/passwd  输出UID小于10的行
awk -F: '$3>=1000{print}' /etc/passwd 输出UID大于等于1000的行
awk -F: '$7=="/bin/bash"{print}' /etc/passwd  输出使用/bin/bash的用户
awk -F: '$7!="/bin/bash"{print}' /etc/passwd   输出没使用/bin/bash的用户
awk -F: 'NR<11{print $1}' /etc/passwd 查看前10行，并显示用户名
awk -F: '$7==" /bin/bash"{print $6}'  /etc/passwd 查看使用/bin/bash解释器的用户，并显示家目录
```

#### 逻辑组合 （&&、||）

&&		//并且

||		 //或者

```shell
awk -F: '$3<10&&$7~/bash/{print}' /etc/passwd  找第3列小于10并且第7列包含bash的行，{print}可以省略
awk -F: '$3>=10&&$3<=20{print}' /etc/passwd  找第3列大于等于10并且小于等于20的行
awk -F: 'NR>=2&&NR<=10{print}' /etc/passwd  找2~10行

awk -F: '$3<5||$3>1000{print}' /etc/passwd  找id号是小于5的或者大于1000的  
```

#### 使用运算作为条件

在一个有200行从1~200的数字序列中，找到能被7整除且包含7的数

```shell
seq 200 | awk '$1%7==0&&$1~/7/{print}'
```

### awk中的if分支

##### 单分支

> 如果满足条件就执行指令

格式： {if(条件){指令}}

示例：找出系统中使用bash作为解释器的用户数量

思路：

> 首先定义变量x=0；
>
> 然后使用if判断如果每找到一行的$7包含bash，就把x+1；
>
> 所有逐行任务结束后，最终使用end任务输出x的值；
>
> 也就是找系统中使bash作为解释器的用户数量

```shell
awk -F: 'BEGIN{x=0}{if($7~/bash/){x++}}END{print x}' /etc/passwd
```

##### 双分支

格式：{if(条件){指令}else{指令}}

示例：统计系统中使用bash作为解释器的用户，和没有使用bash的用户数量

思路：

> 使用if判断如果每找到一行的$7包含bash；
>
> 就把x+1，否则y+1；
>
> 最后使用end输出x与y的值

```shell
awk -F: 'BEGIN{x=0;y=0 }{if($7~/bash/){x++}else{y++}}END{print x,y}' /etc/passwd
```

##### 多分支

格式：{if(条件){指令}else if(条件){指令}else{指令}}

示例：统计系统中使用bash作为解释器的用户，使用nologin的用户，以及其他用户的数量

```shell
awk -F: '{if($7~/bash/){x++}else if($7~/nologin/){y++}else{z++}}END{print x,y,z}' /etc/passwd
```

---------

### awk数组

> 个人理解：存储多个变量的集合！

- 定义数组

格式：数组名[下标]=元素值

- 调用数组

格式：数组名[下标]

- 遍历数组

用法：for(变量名  in  数组名){print  数组名[变量名]}

```shell
a[1]=10			//定义数组a[1]的变量
a[2]=20			////定义数组a[2]的变量
```

示例：显示数组a的所有下标

思路：

> 首先创建数组，名字叫a；
>
> 并且有1与2两个下标，还有对应的10与20两个值；
>
> 然后为了方便查看该数组中所有内容
>
> 使用for循环，可以循环显示所有数组a的下标；
>
> 然后输入变量i，此时的变量i就可以分别显示数组a的所有下标

```shell
awk 'BEGIN{a[1]=10;a[2]=20;for(i in a){print i}}'
```

示例：定义好了数组之后，循环显示数组的值

```shell
awk 'BEGIN{a[1]=10;a[2]=20;for(i in a){print a[i]}}' 
```

示例：定义好了数组之后，循环显示数组的下标与值

```shell
awk'BEGIN{abc["a"]="aaa";abc["b"]="bbb";abc["c"]="ccc";for(i in abc){print i,abc[i]}}' 
```

###### 案例：使用awk统计网络访问量

思路：

> 找到安全日志secure中含有Failed pas的行;
>
> 该行表示有用户登录服务器时输入错误了密码;
>
> 从该行的第11列可以筛选出对方的ip，并通过数组进行收集;
>
> 然后通过for循环显示有多少ip(人)尝试登录过几次我的服务器

```shell
yum -y remove httpd  
yum -y install httpd	 //安装httpd
systemctl restart httpd  //开启服务
netstat -ntulp | grep :80  //查询当前80端口状态
echo "web_test~~~~" > /var/www/html/index.html
yum -y install curl
curl 192.168.4.7  //查看网站内容，防火墙要关闭
cd /var/log/httpd  //进入httpd日志目录
tail -1 access_log  //查看httpd日志的最后一行，也就是最新记录，然后多用不同主机访问该网站，可以让该日志多产生记录
awk '{ip[$1]++}END{for(i in ip){print ip[i],i} }' access_log

awk '/Failed pas/{ip[$11]++}END{for(i in ip){print ip[i],i} }' /var/log/secure  
```

###### 案例：编写脚本，实现检测计算机数据功能

具体监控项目要求如下：

- CPU负载
- 网卡流量
- 内存剩余容量
- 磁盘剩余容量
- 计算机账户数量
- 当前登录账户数量
- 计算机当前开启的进程数量
- 本机已安装的软件包数量

```shell
#!/bin/bash
while :
do
uptime | awk '{print "cpu的15分钟平均负载是"$NF}'
ifconfig eth0 | awk '/RX p/{print "eth0网卡的接收流
量是"$5"字节"}'
free -h | awk '/^Mem/{print "剩余内存是"$4}'
df -h | awk '/\/$/{print "磁盘根分区剩余容量是"$4}'
awk 'END{print "账户总数是"NR"个"}' /etc/passwd
echo "当前开启的进程数量是$(ps aux | wc -l)个"
echo "当前登录的用户数量是$(who | wc -l)个"
echo "总共安装的软件包数量是$(rpm -qa | wc -l)个"
sleep 3
clear
done
```

